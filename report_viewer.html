<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Report Viewer</title>
  <style>
    :root {
      --primary-color: #bddafd;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: Arial, sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    header {
      background-color: #2c3e50;
      color: white;
      padding: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    h1 {
      font-size: 24px;
      margin-bottom: 15px;
    }
    
    .controls {
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      position: relative;
      align-items: center;
      gap: 10px;
    }

    label {
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
    }
    
    select {
      padding: 8px 12px;
      font-size: 14px;
      border: none;
      border-radius: 4px;
      background-color: white;
      cursor: pointer;
      min-width: 300px;
    }
    
    select:focus {
      outline: 2px solid #3498db;
    }
    
    /* Toggle Switch */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.3s;
      border-radius: 24px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: #3498db;
    }

    input:checked + .slider:before {
      transform: translateX(26px);
    }

    /* Search Input */
    .search-input {
      padding: 8px 12px;
      font-size: 14px;
      border: 2px solid #bdc3c7;
      border-radius: 4px;
      background-color: white;
      min-width: 200px;
      transition: border-color 0.2s;
    }

    .search-input:focus {
      outline: none;
      border-color: #3498db;
    }

    .search-input::placeholder {
      color: #95a5a6;
    }

    /* Help Icon & Tooltip */
    .help-icon {
      cursor: help;
      color: #bdc3c7;
      font-size: 16px;
      font-weight: bold;
      user-select: none;
      transition: color 0.2s;
    }

    .help-icon:hover {
      color: #3498db;
    }

    .help-tooltip {
      display: none;
      position: absolute;
      top: calc(100% + 10px);
      right: 0;
      background: #2c3e50;
      color: white;
      padding: 12px 15px;
      border-radius: 6px;
      font-size: 13px;
      line-height: 1.6;
      width: 400px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      text-align: left;
    }

    .help-tooltip code {
      background: #1a252f;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: #5dade2;
    }

    .help-tooltip em {
      color: #95a5a6;
      font-style: italic;
    }

    .help-tooltip::before {
      content: '';
      position: absolute;
      bottom: 100%;
      right: 10px;
      border: 6px solid transparent;
      border-bottom-color: #2c3e50;
    }

    .tooltip-section {
      margin-bottom: 12px;
    }

    .tooltip-section strong {
      font-size: 14px;
      color: rgb(255, 237, 198);
    }

    .tooltip-indent {
      margin-left: 12px;
      margin-top: 4px;
      color: #d6e5ee;
    }

    .tooltip-note {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #455a64;
    }

    /* Viewer Container */
    .viewer-container {
      flex: 1;
      padding: 20px;
      background-color: #ecf0f1;
      overflow: hidden;
    }
    
    iframe {
      width: 100%;
      height: 100%;
      border: 2px solid #bdc3c7;
      border-radius: 4px;
      background-color: white;
    }
    
    .no-selection {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #7f8c8d;
      font-size: 18px;
    }

    /* Footer */
    footer {
      background-color: #34495e;
      color: #bdc3c7;
      padding: 15px 20px;
      text-align: center;
      font-size: 12px;
    }

    footer strong {
      color: var(--primary-color);
      font-weight: 600;
    }
  </style>
</head>

<body>
  <header>
    <h1>Report Viewer</h1>
    <div class="controls">
      <div class="control-group">
        <label for="reportSelector">Select Report:</label>
        <select id="reportSelector">
        </select>
      </div>

      <div class="control-group">
        <label for="evaluationToggle">Show Evaluation:</label>
        <label class="toggle-switch">
          <input type="checkbox" id="evaluationToggle">
          <span class="slider"></span>
        </label>
      </div>

      <div class="control-group">
        <label for="searchFilter">Search:</label>
        <input 
          type="text" 
          id="searchFilter" 
          class="search-input" 
          placeholder="Enter keywords to filter..."
        >
        <span class="help-icon" title="">ⓘ</span>
        <div class="help-tooltip">
          <div class="tooltip-section">
            <strong>Basic Search</strong><br>
            <div class="tooltip-indent">
              • Searches the Name field (case-insensitive, partial match)
            </div>
          </div>
          <div class="tooltip-section">
            <strong>Conditional Search</strong><br>
            <div class="tooltip-indent">
              • Format: <code>@[column]&lt;operator&gt;&lt;value&gt;</code><br>
              • Column name can be abbreviated (e.g., "adv" for "Adventure")<br>
              • Omit column to search all columns<br>
              • Operators: <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>=</code>, <code>&lt;&gt;</code><br>
              • Logic: <code>&lt;&gt;</code> operator uses AND, others use OR<br>
              • Note: <code>=</code> and <code>&lt;&gt;</code> operators are case-insensitive and require exact match
            </div>
          </div>
          <div class="tooltip-section">
            <strong>Examples</strong><br>
            <div class="tooltip-indent">
              • <code>@adv&gt;2</code> - Adventure participation count greater than 2<br>
              • <code>@=0</code> - Any column equals 0<br>
              • <code>@=-</code> - Any column with no value (shown as <code>-</code>)<br>
              • <code>@&lt;&gt;-</code> - Every column is not empty (no <code>-</code> value)
            </div>
          </div>
          <div class="tooltip-note">
            <em>Note: Currently supports single condition only</em>
          </div>
        </div>
      </div>
    </div>
  </header>
  
  <div class="viewer-container">
    <div id="noSelection" class="no-selection">
      Select a report to display it here
    </div>
    <iframe id="documentFrame" style="display: none;"></iframe>
  </div>
  
  <footer>
    <p>Powered by <strong>Ihg</strong> | © 2025 All Rights Reserved</p>
  </footer>
  
  <script>
    const reportSelector = document.getElementById('reportSelector');
    const evaluationToggle = document.getElementById('evaluationToggle');
    const searchFilter = document.getElementById('searchFilter');
    const documentFrame = document.getElementById('documentFrame');
    const noSelection = document.getElementById('noSelection');
    
    // Configuration
    const config = {
      reportFilePattern: /^(.+)_(\d{4})(\d{2})(\d{2})_(\d+)days\.html$/, // pattern: *_YYYYMMDD_Ddays.html
      categorySortOrder: 'desc', // 'asc' or 'desc'
      viewerParamsName: 'viewer_params',
    };

    function loadAndUpdateFormParams(itemName, updateParams = {}) {
      const item = sessionStorage.getItem(itemName);
      let params;
      if (item) {
        params = JSON.parse(item);
      }
      else {
        params = {};
      }

      // Merge with default params and set flag if updated
      let isUpdated = false;
      for (const [key, value] of Object.entries(updateParams)) {
        if (params[key] !== value) {
          params[key] = value;
          isUpdated = true;
        }
      }

      if (isUpdated) {
        saveFormParams(params, itemName);
      }

      return params;
    }

    function saveFormParams(params, itemName) {
      sessionStorage.setItem(itemName, JSON.stringify(params));
    }

    function saveViewerParam(key, value) {
      loadAndUpdateFormParams(config.viewerParamsName, {[key]: value});
    }

    function applyViewerParams(params) {
      if (!params) return;
      if (params.pathname != null) {
        reportSelector.value = params.pathname;
        loadReport(params.pathname);
      }
      if (params.showEval != null) {
        evaluationToggle.checked = params.showEval;
      }
      if (params.searchKeyword != null) {
        searchFilter.value = params.searchKeyword;
      }
    }

    // Help tooltip hover functionality
    const helpIcon = document.querySelector('.help-icon');
    const helpTooltip = document.querySelector('.help-tooltip');
    let hideTimeout;

    function showTooltip() {
      clearTimeout(hideTimeout);
      helpTooltip.style.display = 'block';
    }

    function hideTooltip() {
      hideTimeout = setTimeout(() => {
        helpTooltip.style.display = 'none';
      }, 400); // Keep tooltip visible for 300ms after mouse leaves
    }

    helpIcon.addEventListener('mouseenter', showTooltip);
    helpIcon.addEventListener('mouseleave', hideTooltip);
    helpTooltip.addEventListener('mouseenter', showTooltip);
    helpTooltip.addEventListener('mouseleave', hideTooltip);

    // Extract date from filename
    function extractInfoFromName(filename) {
      const match = filename.match(config.reportFilePattern);
      if (!match) return { filename, docType: null, startDate: null, endDate: null };
      
      const [, docType, year, month, day, durationInDays] = match;
      const startDate = new Date(year, month - 1, day);
      const endDate = new Date(startDate.getTime() + (durationInDays - 1) * 86400000);
      return { filename, docType, startDate, endDate };
    }
    
    // Format date for display
    function formatDate(fileObj) {
      if (fileObj.startDate && fileObj.endDate)
        return `${fileObj.startDate.toDateString()} ~ ${fileObj.endDate.toDateString()}`;
      return 'Unknown Date';
    }

    function toCamelCase(str) {
      return str
        .replace(/[\s_]+/g, ' ') // replace underscores/spaces with single space
        .trim()
        .replace(/[^a-zA-Z]+([a-z])/g, (match, chr) => chr.toUpperCase())
        .replace(/([a-z]{2})([A-Z])/g, (match, p1, p2) => p1 + ' ' + p2)
        .replace(/([A-Z]{2})([a-z])([a-z])/g, (match, p1, p2, p3) => p1 + ' ' + p2.toUpperCase() + p3)
        .replace(/^./, str[0].toUpperCase());
    }

    function formatFilename(filename) {
      const fileObj = extractInfoFromName(filename);
      if (fileObj.docType && fileObj.startDate && fileObj.endDate) {
        return `${toCamelCase(fileObj.docType)} (${formatDate(fileObj)})`;
      }
      // Fallback: just return filename
      return toCamelCase(filename.replace(/\.html$/i, ''));
    }

    // Process and sort files
    function processFileList(fileList) {
      // Filter files matching the pattern and extract dates
      const processedFiles = fileList
        .map(extractInfoFromName)
        .filter(item => item !== null);
      
      // Sort by startDate, then by docType
      processedFiles.sort((a, b) => {
        const order = config.categorySortOrder === 'desc' ? -1 : 1;
        
        // startDate comparison (null last)
        const aDateNull = a.startDate === null;
        const bDateNull = b.startDate === null;
        if (aDateNull !== bDateNull) return aDateNull ? 1 : -1;
        if (!aDateNull) {
          const dateComp = order * (a.startDate - b.startDate);
          if (dateComp !== 0) return dateComp;
        }
        
        // docType comparison (null last)
        const aTypeNull = a.docType === null;
        const bTypeNull = b.docType === null;
        if (aTypeNull !== bTypeNull) return aTypeNull ? 1 : -1;
        if (!aTypeNull) return a.docType.localeCompare(b.docType);
        
        return 0;
      });

      return processedFiles;
    }

    // Load files from JSON
    async function loadCategory(category) {
      try {
        const response = await fetch('files.json');
        const data = await response.json();
        populateDropdown(data, category);
      } catch (error) {
        console.error('Error loading files:', error);
        const option = document.createElement('option');
        option.textContent = 'Failed to load file list';
        option.disabled = true;
        reportSelector.appendChild(option);
      }
    }

    // Populate dropdown with files
    function populateDropdown(data, reportCategory) {
      // Clear existing options
      reportSelector.replaceChildren();

      let isEmpty = true;
      // Add options for each category
      for (const [category, {title, folderPath, files}] of Object.entries(data)) {
        if (reportCategory && reportCategory !== category) continue;
        
        // Sort files
        const processedFiles = processFileList(files);

        if (processedFiles.length === 0) continue;
        
        // Create optgroup
        const optgroup = document.createElement('optgroup');
        optgroup.label = title;
        
        // Add files
        processedFiles.forEach(fileObj => {
          const option = document.createElement('option');
          option.value = `${folderPath}\\${fileObj.filename}`;
          option.textContent = formatFilename(fileObj.filename); // TODO: More descriptive names can be added here
          optgroup.appendChild(option);
        });

        isEmpty &&= processedFiles.length === 0;
        reportSelector.appendChild(optgroup);
      }

      // Add default option if none selected
      if (isEmpty) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = '-- No reports available --';
        option.selected = true;
        option.disabled = true;
        option.hidden = true;
        reportSelector.prepend(option);
      }
    }

    function makeUrl(pathname, params) {
      if (!pathname) return '';
      const query = Object.entries(params)
        .filter(([key, value]) => value != null && value !== '')
        .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
        .join('&');
      return query ? `${pathname}?${query}` : pathname;
    }

    function loadReport(pathname) {
      if (pathname) {
        // Show iframe, hide message
        documentFrame.style.display = 'block';
        noSelection.style.display = 'none';
        const url = makeUrl(pathname, { _t: new Date().getTime() });
        documentFrame.contentWindow.location.replace(url);
      } else {
        // Show message, hide iframe
        documentFrame.style.display = 'none';
        noSelection.style.display = 'flex';
        // Reset frame without adding to history stack
        documentFrame.contentWindow.location.replace('about:blank');
      }
    }

    function toggleEvaluation(showEval = null, forwarded = false) {
      try {
        if (forwarded) {
          if (showEval == null)
            showEval = !evaluationToggle.checked;
          evaluationToggle.checked = showEval;
        }
        if (documentFrame && documentFrame.contentWindow && typeof documentFrame.contentWindow.toggleEvaluation === 'function')
          documentFrame.contentWindow.toggleEvaluation(showEval, forwarded);
      } catch (err) {
        console.error("Access denied or function not found:", err);
      }
    }

    function applySearchFilter(searchKeyword, forwarded = false) {
      try {
        if (forwarded) {
          searchFilter.value = searchKeyword;
        }
        if (documentFrame && documentFrame.contentWindow && typeof documentFrame.contentWindow.applySearchFilter === 'function')
          documentFrame.contentWindow.applySearchFilter(searchKeyword, forwarded);
      } catch (err) {
        console.error("Access denied or function not found:", err);
      }
    }

    function sort(header, order, forwarded = false) {
      try {
        if (forwarded) {
          // No local control to update
        }
        if (documentFrame && documentFrame.contentWindow && typeof documentFrame.contentWindow.sort === 'function')
          documentFrame.contentWindow.sort(header, order, forwarded);
      } catch (err) {
        console.error("Access denied or function not found:", err);
      }
    }

    // Handle report selection
    reportSelector.addEventListener('change', (e) => {
      const pathname = e.target.value;
      if (e.isTrusted)
        saveViewerParam('pathname', pathname);

      loadReport(pathname);
    });

    // Handle evaluation toggle
    evaluationToggle.addEventListener('change', (e) => {
      const showEval = e.target.checked;
      if (e.isTrusted)
        saveViewerParam('showEval', showEval);

      toggleEvaluation(showEval);
    });

    // Handle search filter
    searchFilter.addEventListener('input', (e) => {
      const searchKeyword = e.target.value.trim();
      if (e.isTrusted)
        saveViewerParam('searchKeyword', searchKeyword);

      applySearchFilter(searchKeyword);
    });

    // Initialize
    window.addEventListener('DOMContentLoaded', () => {
      const params = loadAndUpdateFormParams(config.viewerParamsName);
      loadCategory(params.category).then(() => {
        // Apply saved params after loading files
        applyViewerParams(params);
      });
    });
  </script>
</body>
</html>